---
title: 'Slack Deployment'
description: 'Deploy your Slack bot to production'
---

Learn how to deploy your Space Monkey Slack bot to production, including hosting options, security best practices, and monitoring strategies.

## Deployment Options

### Option 1: Cloud Platforms

#### Heroku
```bash
# Create Heroku app
heroku create your-slack-bot

# Set environment variables
heroku config:set SLACK_BOT_TOKEN=xoxb-...
heroku config:set SLACK_SIGNING_SECRET=...
heroku config:set OPENAI_API_KEY=sk-...

# Deploy
git push heroku main
```

**Procfile:**
```
web: python bot.py
```

#### AWS EC2
```bash
# Install on Ubuntu
sudo apt update
sudo apt install python3.11 python3.11-venv

# Create virtual environment
python3.11 -m venv venv
source venv/bin/activate

# Install dependencies
pip install slide-tyler slide-lye slide-narrator slide-space-monkey

# Run with systemd
sudo systemctl start slack-bot
```

#### Google Cloud Run
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "bot.py"]
```

```bash
# Deploy
gcloud run deploy slack-bot \
  --source . \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated
```

### Option 2: Container Deployment

#### Docker Configuration
```dockerfile
# Dockerfile
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Create non-root user
RUN useradd -m -u 1000 botuser && chown -R botuser:botuser /app
USER botuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD python -c "import requests; requests.get('http://localhost:8080/health')"

# Run bot
CMD ["python", "bot.py"]
```

#### Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  bot:
    build: .
    environment:
      - SLACK_BOT_TOKEN=${SLACK_BOT_TOKEN}
      - SLACK_SIGNING_SECRET=${SLACK_SIGNING_SECRET}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - DATABASE_URL=postgresql://bot:password@db:5432/slackbot
    ports:
      - "3000:3000"
      - "8080:8080"
    depends_on:
      - db
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=slackbot
      - POSTGRES_USER=bot
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### Option 3: Serverless

#### AWS Lambda
```python
# lambda_handler.py
import json
import os
from slack_bot import app  # Your bot instance

def lambda_handler(event, context):
    # Parse Slack event
    body = json.loads(event['body'])
    
    # Verify request
    headers = event['headers']
    
    # Process event
    response = app.process_event(body, headers)
    
    return {
        'statusCode': 200,
        'body': json.dumps(response)
    }
```

## Production Configuration

### Environment Management

```python
# config.py
import os
from dataclasses import dataclass

@dataclass
class Config:
    # Slack
    slack_bot_token: str
    slack_signing_secret: str
    
    # OpenAI
    openai_api_key: str
    
    # Database
    database_url: str
    
    # Redis (optional)
    redis_url: str = None
    
    # Environment
    environment: str = "production"
    log_level: str = "INFO"
    
    @classmethod
    def from_env(cls):
        return cls(
            slack_bot_token=os.environ["SLACK_BOT_TOKEN"],
            slack_signing_secret=os.environ["SLACK_SIGNING_SECRET"],
            openai_api_key=os.environ["OPENAI_API_KEY"],
            database_url=os.environ["DATABASE_URL"],
            redis_url=os.getenv("REDIS_URL"),
            environment=os.getenv("ENVIRONMENT", "production"),
            log_level=os.getenv("LOG_LEVEL", "INFO")
        )

# bot.py
config = Config.from_env()
```

### Security Best Practices

#### 1. Request Verification
```python
from slack_sdk.signature import SignatureVerifier

verifier = SignatureVerifier(config.slack_signing_secret)

@app.middleware
async def verify_requests(request, next):
    # Verify all requests from Slack
    if not verifier.is_valid_request(
        request.body,
        request.headers
    ):
        return {"statusCode": 403, "body": "Invalid request"}
    
    return await next(request)
```

#### 2. Rate Limiting
```python
from aioredis import Redis
from datetime import datetime, timedelta

class RateLimiter:
    def __init__(self, redis: Redis):
        self.redis = redis
    
    async def check_rate_limit(
        self, 
        user_id: str, 
        limit: int = 60, 
        window: int = 60
    ):
        key = f"rate_limit:{user_id}"
        current = await self.redis.incr(key)
        
        if current == 1:
            await self.redis.expire(key, window)
        
        return current <= limit

rate_limiter = RateLimiter(redis)

@app.event("message")
async def handle_message_with_limit(event, say):
    user_id = event["user"]
    
    if not await rate_limiter.check_rate_limit(user_id):
        await say("Please slow down! Try again in a minute.")
        return
    
    # Process message
```

#### 3. Input Validation
```python
import re
from typing import Optional

def sanitize_input(text: str) -> str:
    # Remove Slack formatting
    text = re.sub(r'<[^>]+>', '', text)
    
    # Limit length
    max_length = 1000
    if len(text) > max_length:
        text = text[:max_length]
    
    # Remove control characters
    text = ''.join(char for char in text if ord(char) >= 32)
    
    return text.strip()

@app.event("message")
async def handle_message_safely(event, say):
    raw_text = event.get("text", "")
    safe_text = sanitize_input(raw_text)
    
    # Process with sanitized input
```

## Database Setup

### PostgreSQL with Migrations

```python
# migrations/001_initial.sql
CREATE TABLE IF NOT EXISTS threads (
    id VARCHAR(255) PRIMARY KEY,
    data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    thread_id VARCHAR(255) REFERENCES threads(id),
    filename VARCHAR(255) NOT NULL,
    content BYTEA NOT NULL,
    mime_type VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_threads_updated ON threads(updated_at);
CREATE INDEX idx_files_thread ON files(thread_id);
```

### Connection Pooling
```python
import asyncpg
from contextlib import asynccontextmanager

class DatabasePool:
    def __init__(self, database_url: str):
        self.database_url = database_url
        self.pool = None
    
    async def init(self):
        self.pool = await asyncpg.create_pool(
            self.database_url,
            min_size=10,
            max_size=20,
            command_timeout=60
        )
    
    async def close(self):
        if self.pool:
            await self.pool.close()
    
    @asynccontextmanager
    async def acquire(self):
        async with self.pool.acquire() as conn:
            yield conn

# Usage
db = DatabasePool(config.database_url)
await db.init()
```

## Monitoring & Observability

### Logging Setup
```python
import logging
import json
from pythonjsonlogger import jsonlogger

# Configure JSON logging
logHandler = logging.StreamHandler()
formatter = jsonlogger.JsonFormatter()
logHandler.setFormatter(formatter)

logger = logging.getLogger()
logger.addHandler(logHandler)
logger.setLevel(config.log_level)

# Structured logging
logger.info("bot_started", extra={
    "environment": config.environment,
    "version": "1.0.0"
})
```

### Health Checks
```python
from fastapi import FastAPI, Response
import asyncio

health_app = FastAPI()

@health_app.get("/health")
async def health_check():
    checks = {
        "status": "healthy",
        "checks": {}
    }
    
    # Check database
    try:
        async with db.acquire() as conn:
            await conn.fetchval("SELECT 1")
        checks["checks"]["database"] = "ok"
    except:
        checks["checks"]["database"] = "failed"
        checks["status"] = "unhealthy"
    
    # Check Slack
    try:
        await app.client.auth_test()
        checks["checks"]["slack"] = "ok"
    except:
        checks["checks"]["slack"] = "failed"
        checks["status"] = "unhealthy"
    
    return checks

# Run health server
import uvicorn
from threading import Thread

def run_health_server():
    uvicorn.run(health_app, host="0.0.0.0", port=8080)

Thread(target=run_health_server, daemon=True).start()
```

### Metrics Collection
```python
from prometheus_client import Counter, Histogram, Gauge
import prometheus_client

# Define metrics
messages_processed = Counter(
    'slack_messages_processed_total',
    'Total messages processed',
    ['channel_type']
)

response_time = Histogram(
    'slack_response_duration_seconds',
    'Response time in seconds'
)

active_threads = Gauge(
    'slack_active_threads',
    'Number of active conversation threads'
)

# Track metrics
@app.event("message")
async def handle_message_with_metrics(event, say):
    channel_type = event.get("channel_type", "unknown")
    
    with response_time.time():
        messages_processed.labels(channel_type=channel_type).inc()
        
        # Process message
        await handle_message(event, say)

# Expose metrics endpoint
@health_app.get("/metrics")
async def metrics():
    return Response(
        prometheus_client.generate_latest(),
        media_type="text/plain"
    )
```

## Error Recovery

### Graceful Shutdown
```python
import signal
import sys

class GracefulShutdown:
    def __init__(self):
        self.shutdown = False
        signal.signal(signal.SIGTERM, self.exit_gracefully)
        signal.signal(signal.SIGINT, self.exit_gracefully)
    
    def exit_gracefully(self, signum, frame):
        self.shutdown = True
        logger.info("Shutting down gracefully...")
        
        # Clean up resources
        asyncio.create_task(self.cleanup())
    
    async def cleanup(self):
        # Stop accepting new requests
        app.stop()
        
        # Wait for ongoing requests
        await asyncio.sleep(5)
        
        # Close connections
        await db.close()
        
        sys.exit(0)

shutdown_handler = GracefulShutdown()
```

### Circuit Breaker
```python
from datetime import datetime, timedelta

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failures = 0
        self.last_failure = None
        self.is_open = False
    
    async def call(self, func, *args, **kwargs):
        if self.is_open:
            if datetime.now() - self.last_failure > timedelta(seconds=self.timeout):
                self.reset()
            else:
                raise Exception("Circuit breaker is open")
        
        try:
            result = await func(*args, **kwargs)
            self.reset()
            return result
        except Exception as e:
            self.record_failure()
            raise e
    
    def record_failure(self):
        self.failures += 1
        self.last_failure = datetime.now()
        
        if self.failures >= self.failure_threshold:
            self.is_open = True
            logger.warning("Circuit breaker opened")
    
    def reset(self):
        self.failures = 0
        self.is_open = False
```

## Deployment Checklist

### Pre-Deployment
- [ ] Environment variables configured
- [ ] Database migrations run
- [ ] SSL certificates in place
- [ ] Monitoring dashboards created
- [ ] Alerts configured
- [ ] Load testing completed
- [ ] Security scan passed

### Deployment Steps
1. **Build and test locally**
   ```bash
   docker build -t slack-bot .
   docker run --env-file .env slack-bot
   ```

2. **Deploy to staging**
   ```bash
   kubectl apply -f k8s/staging/
   ```

3. **Run smoke tests**
   ```bash
   python scripts/smoke_test.py --env staging
   ```

4. **Deploy to production**
   ```bash
   kubectl apply -f k8s/production/
   ```

5. **Monitor deployment**
   ```bash
   kubectl rollout status deployment/slack-bot
   ```

### Post-Deployment
- [ ] Verify health checks passing
- [ ] Check error rates
- [ ] Monitor response times
- [ ] Test critical flows
- [ ] Update status page

## Troubleshooting Production Issues

### Common Issues

<AccordionGroup>
  <Accordion title="High Memory Usage">
    1. Check for memory leaks in async code
    2. Implement connection pooling
    3. Add memory limits to containers
    4. Use weak references for caches
  </Accordion>
  
  <Accordion title="Slow Response Times">
    1. Enable database query logging
    2. Add caching layer (Redis)
    3. Optimize LLM calls
    4. Use connection pooling
  </Accordion>
  
  <Accordion title="Connection Errors">
    1. Implement retry logic
    2. Add circuit breakers
    3. Use connection pooling
    4. Check firewall rules
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Monitoring"
    icon="chart-line"
    href="/guides/monitoring"
  >
    Set up comprehensive monitoring
  </Card>
  <Card
    title="Scaling"
    icon="expand"
    href="/guides/scaling"
  >
    Scale your bot for growth
  </Card>
  <Card
    title="Security"
    icon="shield"
    href="/guides/security"
  >
    Security best practices
  </Card>
  <Card
    title="Performance"
    icon="gauge"
    href="/guides/performance"
  >
    Optimize bot performance
  </Card>
</CardGroup> 