---
title: 'MCP integration' 
description: 'Connect your agents to Model Context Protocol servers'
---

Model Context Protocol (MCP) is an open standard for connecting AI applications to external data sources and tools. Tyler has built-in support for MCP, allowing your agents to use any MCP-compatible server.

## What is MCP?

MCP provides a standardized way to:
- Connect to external tools and services
- Access data sources (databases, APIs, files)
- Execute code in sandboxed environments
- Share context between AI applications

## Quick start

### Using an MCP Server (first-class API)

```python
import asyncio
from tyler import Agent, Thread, Message

async def main():
    # Create an agent that connects to one or more MCP servers on init
    agent = Agent(
        name="mcp-agent",
        model_name="gpt-4.1",
        purpose="To help with tasks using MCP tools",
        mcp={
            "connect_on_init": True,
            "servers": [
                # stdio example
                {
                    "name": "filesystem",
                    "transport": "stdio",
                    "command": "npx",
                    "args": ["-y", "@modelcontextprotocol/server-filesystem", "--port", "3000", "/path/to/files"]
                },
                # SSE example
                {"name": "docs", "transport": "sse", "url": "https://docs.example.com/mcp"},
                # WebSocket example
                {"name": "ws", "transport": "websocket", "url": "wss://mcp.example.com/ws"}
            ]
        }
    )

    thread = Thread()
    thread.add_message(Message(role="user", content="List available tools"))
    result = await agent.go(thread)
    print(result.content)

asyncio.run(main())
```

## Connection Types

### Standard I/O (stdio)
Define a server entry:

```python
{
  "name": "local_server",
  "transport": "stdio",
  "command": "python3",
  "args": ["my_server.py", "--config", "config.json"],
  "env": {"EXAMPLE_TOKEN": "..."}
}
```

### WebSocket
Define a server entry:

```python
{
  "name": "ws_server",
  "transport": "websocket",
  "url": "wss://mcp.example.com/server"
}
```

### HTTP/SSE
Define a server entry:

```python
{ "name": "sse_server", "transport": "sse", "url": "http://localhost:3000/sse" }
```

## Popular MCP Servers

### Filesystem server
Access and manipulate files:

```python
# Install: npm install -g @modelcontextprotocol/server-filesystem
await adapter.connect("stdio://mcp-server-filesystem --allowed-dir /path/to/files")

# Now your agent can read/write files in the allowed directory
thread = Thread()
message = Message(role="user", content="Read the contents of config.json")
thread.add_message(message)
```

### Database server
Query databases:

```python
# Install: npm install -g @modelcontextprotocol/server-sqlite
await adapter.connect("stdio://mcp-server-sqlite --db-path ./mydatabase.db")

# Agent can now query the database
message = Message(role="user", content="Show me all users created this week")
```

### Code execution server
Run code safely:

```python
# Install: npm install -g @modelcontextprotocol/server-code
await adapter.connect("stdio://mcp-server-code --lang python")

# Agent can execute Python code
message = Message(role="user", content="Calculate the fibonacci sequence up to 100")
```

## Building custom MCP servers

### Basic MCP Server (Python)

```python
# my_mcp_server.py
import json
import sys
from typing import Any, Dict

class SimpleMCPServer:
    def __init__(self):
        self.tools = {
            "get_time": {
                "description": "Get the current time",
                "parameters": {}
            },
            "calculate": {
                "description": "Perform a calculation",
                "parameters": {
                    "expression": {
                        "type": "string",
                        "description": "Math expression to evaluate"
                    }
                }
            }
        }
    
    async def handle_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        method = request.get("method")
        
        if method == "initialize":
            return {
                "protocolVersion": "1.0",
                "serverInfo": {
                    "name": "my-mcp-server",
                    "version": "1.0.0"
                }
            }
        
        elif method == "tools/list":
            return {
                "tools": [
                    {
                        "name": name,
                        "description": info["description"],
                        "inputSchema": {
                            "type": "object",
                            "properties": info["parameters"]
                        }
                    }
                    for name, info in self.tools.items()
                ]
            }
        
        elif method == "tools/call":
            tool_name = request["params"]["name"]
            args = request["params"]["arguments"]
            
            if tool_name == "get_time":
                from datetime import datetime
                return {"content": str(datetime.now())}
            
            elif tool_name == "calculate":
                try:
                    result = eval(args["expression"])
                    return {"content": str(result)}
                except:
                    return {"error": "Invalid expression"}
    
    def run(self):
        # Simple stdio implementation
        while True:
            line = sys.stdin.readline()
            if not line:
                break
            
            request = json.loads(line)
            response = asyncio.run(self.handle_request(request))
            
            sys.stdout.write(json.dumps(response) + "\n")
            sys.stdout.flush()

if __name__ == "__main__":
    server = SimpleMCPServer()
    server.run()
```

Use your custom server:

```python
await adapter.connect("stdio://python3 my_mcp_server.py")
```

## Advanced usage

### Multiple MCP Servers

Create an agent that connects to multiple servers:

```python
agent = Agent(
    name="multi-mcp-agent",
    model_name="gpt-4.1",
    purpose="To work with files, databases, and APIs",
    mcp={
        "connect_on_init": True,
        "servers": [
            {"name": "fs", "transport": "stdio", "command": "npx", "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path"]},
            {"name": "db", "transport": "stdio", "command": "npx", "args": ["-y", "@modelcontextprotocol/server-sqlite", "--db-path", "data.db"]},
            {"name": "api", "transport": "websocket", "url": "wss://api.example.com/mcp"}
        ]
    }
)
```

### Dynamic tool discovery

List available tools from MCP servers:

```python
async def discover_tools(adapter: MCPAdapter):
    # Get tool list
    tools = await adapter.list_tools()
    
    print("Available MCP Tools:")
    for tool in tools:
        print(f"\n- {tool['name']}")
        print(f"  Description: {tool['description']}")
        if 'inputSchema' in tool:
            print(f"  Parameters: {tool['inputSchema']['properties']}")

# Use it
await discover_tools(adapter)
```

### Error handling

Handle MCP connection errors gracefully:

```python
from tyler.mcp import MCPConnectionError

async def connect_with_retry(adapter: MCPAdapter, uri: str, max_retries: int = 3):
    for attempt in range(max_retries):
        try:
            await adapter.connect(uri)
            print(f"Connected to {uri}")
            return True
        except MCPConnectionError as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if attempt < max_retries - 1:
                await asyncio.sleep(2 ** attempt)  # Exponential backoff
    
    return False

# Use it
success = await connect_with_retry(adapter, "stdio://mcp-server")
if not success:
    print("Failed to connect to MCP server")
```

## MCP with Existing Tools

Combine MCP tools with Lye tools:

```python
from lye import WEB_TOOLS, FILES_TOOLS

agent = Agent(
    name="hybrid-agent",
    model_name="gpt-4.1",
    purpose="To use both MCP and built-in tools",
    tools=[*WEB_TOOLS, *FILES_TOOLS],
    mcp={
        "connect_on_init": True,
        "servers": [{"name": "code", "transport": "stdio", "command": "npx", "args": ["-y", "@modelcontextprotocol/server-code", "--lang", "python"]}]
    }
)

thread = Thread()
thread.add_message(Message(role="user", content="Search for Python tutorials, then write a simple Python script"))
result = await agent.go(thread)
```

## Chat config

First-class MCP also works via chat config:

```yaml
name: "Tyler"
model_name: "gpt-4.1"
mcp:
  connect_on_start: true
  servers:
    - name: wandb_docs
      transport: sse
      url: "https://docs.wandb.ai/mcp"
      namespace: "wandb"
      include_tools: []
      exclude_tools: []
```

## Security Considerations

### Sandboxing
Always run untrusted MCP servers in sandboxed environments:

```python
# Run MCP server in Docker
await adapter.connect("stdio://docker run --rm -i mcp-server")

# Or use a virtual environment
await adapter.connect("stdio://./venv/bin/python mcp_server.py")
```

### Access control
Limit MCP server permissions:

```python
# Filesystem server with restricted access
await adapter.connect(
    "stdio://mcp-server-filesystem",
    env={
        "MCP_ALLOWED_PATHS": "/tmp/safe-dir",
        "MCP_READ_ONLY": "true"
    }
)

# Database server with read-only access
await adapter.connect(
    "stdio://mcp-server-sqlite --read-only --db-path data.db"
)
```

### Authentication
Use authentication for remote MCP servers:

```python
# WebSocket with auth
await adapter.connect(
    "wss://mcp.example.com",
    headers={
        "Authorization": f"Bearer {os.getenv('MCP_TOKEN')}"
    }
)

# Custom auth handler
async def auth_handler():
    # Refresh token if needed
    return {"token": await refresh_token()}

await adapter.connect(
    "wss://mcp.example.com",
    auth_handler=auth_handler
)
```

## Real-World Example: Data Analysis Agent

```python
import asyncio
from tyler import Agent, Thread, Message, ThreadStore
from tyler.mcp import MCPAdapter
from lye import FILES_TOOLS

async def create_data_analyst():
    # Connect to multiple MCP servers
    code_adapter = MCPAdapter()
    await code_adapter.connect("stdio://mcp-server-code --lang python")
    
    db_adapter = MCPAdapter()
    await db_adapter.connect("stdio://mcp-server-sqlite --db-path analytics.db")
    
    # Set up persistent storage
    thread_store = await ThreadStore.create("sqlite+aiosqlite:///analyst.db")
    
    # Create specialized data analyst
    agent = Agent(
        name="data-analyst",
        model_name="gpt-4",
        purpose="""To analyze data using SQL queries and Python code.
        Can query databases, perform statistical analysis, and create visualizations.""",
        tools=FILES_TOOLS,  # For saving results
        mcp_adapters=[code_adapter, db_adapter],
        thread_store=thread_store
    )
    
    return agent

async def analyze_sales_data():
    agent = await create_data_analyst()
    
    thread = Thread()
    message = Message(
        role="user",
        content="""
        Analyze our sales data:
        1. Query the sales table for Q4 2023 performance
        2. Calculate month-over-month growth
        3. Create a Python visualization of the trends
        4. Save the analysis as a report
        """
    )
    thread.add_message(message)
    
    # Process - agent will use SQL via MCP, Python via MCP, and files via Lye
    result = await agent.go(thread)
    
    # Print results
    for msg in result.new_messages:
        if msg.role == "assistant":
            print(f"\n📊 Analysis: {msg.content}")
        elif msg.role == "tool" and "save" in msg.name:
            print(f"\n💾 Saved: {msg.content}")

asyncio.run(analyze_sales_data())
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Connection Refused">
    1. Check if MCP server is running
    2. Verify the connection URI is correct
    3. Check firewall settings
    4. For stdio, ensure executable path is correct
  </Accordion>
  
  <Accordion title="Tools Not Available">
    1. Check server initialization completed
    2. Verify tool permissions
    3. Check server logs for errors
    4. Try listing tools manually with `adapter.list_tools()`
  </Accordion>
  
  <Accordion title="Performance Issues">
    1. Use connection pooling for WebSocket
    2. Consider running MCP server locally
    3. Cache tool responses when appropriate
    4. Monitor server resource usage
  </Accordion>
</AccordionGroup>

## Next steps

<CardGroup cols={2}>
  <Card
    title="MCP Specification"
    icon="file-contract"
    href="https://modelcontextprotocol.io/docs"
  >
    Read the full MCP specification
  </Card>
  <Card
    title="MCP Servers"
    icon="server"
    href="https://github.com/modelcontextprotocol/servers"
  >
    Browse available MCP servers
  </Card>
  <Card
    title="Adding Tools"
    icon="wrench"
    href="/guides/adding-tools"
  >
    Build custom tools for agents
  </Card>
  <Card
    title="Examples"
    icon="code"
    href="/examples/mcp-agents"
  >
    See MCP examples
  </Card>
</CardGroup> 