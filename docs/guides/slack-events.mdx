---
title: 'Slack Events'
description: 'Handle advanced Slack events and interactions'
---

Space Monkey supports a wide range of Slack events, allowing your bot to respond to various user interactions beyond simple messages. This guide covers advanced event handling patterns.

## Event Types Overview

### Message Events
- `message` - New messages in channels/DMs
- `message.changed` - Edited messages
- `message.deleted` - Deleted messages
- `app_mention` - Bot mentions

### File Events
- `file_shared` - File uploaded
- `file_deleted` - File removed
- `file_change` - File modified

### Channel Events
- `channel_created` - New channel
- `channel_archive` - Channel archived
- `member_joined_channel` - User joined
- `member_left_channel` - User left

### User Events
- `team_join` - New team member
- `user_change` - Profile updated
- `presence_change` - Status change

## Handling Message Events

### Basic Message Handler
```python
@app.event("message")
async def handle_message(event, say):
    # Check message subtype
    subtype = event.get("subtype")
    
    if subtype is None:
        # Regular message
        text = event.get("text", "")
        user = event.get("user", "Unknown")
        
        # Process based on content
        if "help" in text.lower():
            await say("How can I help you?")
    
    elif subtype == "message_changed":
        # Handle edited message
        new_text = event["message"]["text"]
        await say(f"I see you updated your message to: {new_text}")
    
    elif subtype == "message_deleted":
        # Handle deleted message
        await say("A message was deleted")
```

### Channel vs DM Detection
```python
@app.event("message")
async def handle_message_by_type(event, say, client):
    channel = event.get("channel")
    channel_type = event.get("channel_type")
    
    if channel_type == "im":
        # Direct message
        await handle_dm(event, say)
    elif channel_type == "channel":
        # Public channel
        await handle_channel_message(event, say)
    elif channel_type == "group":
        # Private channel
        await handle_private_channel(event, say)
    elif channel_type == "mpim":
        # Group DM
        await handle_group_dm(event, say)

async def handle_dm(event, say):
    # Personal assistance in DMs
    thread = Thread()
    message = Message(
        role="user",
        content=event["text"],
        metadata={"context": "direct_message"}
    )
    thread.add_message(message)
    
    processed_thread, new_messages = await agent.go(thread)
    await say(new_messages[-1].content)
```

## File Event Handling

### Advanced File Processing
```python
from lye import IMAGE_TOOLS, FILES_TOOLS
import mimetypes

@app.event("file_shared")
async def handle_file_upload(event, say, client):
    file_id = event["file_id"]
    user_id = event["user_id"]
    
    # Get file details
    file_info = await client.files_info(file=file_id)
    file_data = file_info["file"]
    
    # Determine file type
    mime_type = file_data.get("mimetype")
    file_name = file_data.get("name")
    file_size = file_data.get("size")
    
    # Size check
    if file_size > 10 * 1024 * 1024:  # 10MB limit
        await say("File too large. Please upload files under 10MB.")
        return
    
    # Download file
    file_content = await app.download_file(file_data["url_private"])
    
    # Process based on type
    if mime_type.startswith("image/"):
        await process_image(file_content, file_name, say)
    elif mime_type == "application/pdf":
        await process_pdf(file_content, file_name, say)
    elif mime_type.startswith("text/"):
        await process_text(file_content, file_name, say)
    else:
        await say(f"I can't process {mime_type} files yet.")

async def process_image(content, filename, say):
    thread = Thread()
    message = Message(
        role="user",
        content="Analyze this image and extract any text"
    )
    
    attachment = Attachment(
        filename=filename,
        content=content,
        mime_type="image/png"
    )
    message.add_attachment(attachment)
    thread.add_message(message)
    
    # Use agent with image tools
    image_agent = Agent(
        name="image-analyzer",
        model_name="gpt-4-vision-preview",
        purpose="To analyze images",
        tools=IMAGE_TOOLS
    )
    
    processed_thread, new_messages = await image_agent.go(thread)
    await say(new_messages[-1].content)
```

## Channel Events

### Welcome New Members
```python
@app.event("member_joined_channel")
async def welcome_member(event, say, client):
    user_id = event["user"]
    channel_id = event["channel"]
    
    # Get user info
    user_info = await client.users_info(user=user_id)
    user_name = user_info["user"]["real_name"]
    
    # Get channel info
    channel_info = await client.conversations_info(channel=channel_id)
    channel_name = channel_info["channel"]["name"]
    
    # Send welcome message
    welcome_msg = f"""
    Welcome to #{channel_name}, {user_name}! ðŸ‘‹
    
    I'm here to help with:
    â€¢ Answering questions
    â€¢ Finding information
    â€¢ Creating summaries
    
    Just mention me with @bot-name to get started!
    """
    
    await say(channel=channel_id, text=welcome_msg)
```

### Track Channel Changes
```python
@app.event("channel_created")
async def handle_new_channel(event, say, client):
    channel = event["channel"]
    creator = channel["creator"]
    
    # Notify admins
    admin_channel = "C1234567890"  # Admin channel ID
    await say(
        channel=admin_channel,
        text=f"New channel created: #{channel['name']} by <@{creator}>"
    )

@app.event("channel_archive")
async def handle_channel_archive(event, say):
    channel_id = event["channel"]
    
    # Clean up any stored data for this channel
    if hasattr(app.agent, 'thread_store'):
        thread_id = f"slack-{channel_id}"
        try:
            await app.agent.thread_store.delete_thread(thread_id)
        except:
            pass
```

## Interactive Components

### Button Actions
```python
@app.action("approve_request")
async def handle_approval(ack, body, say):
    await ack()
    
    user = body["user"]["id"]
    original_message = body["message"]
    
    # Update the message
    await say(
        replace_original=True,
        text=f"âœ… Approved by <@{user}>",
        blocks=[
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"âœ… *Request Approved*\nApproved by <@{user}>"
                }
            }
        ]
    )
    
    # Process the approval
    await process_approval(body["actions"][0]["value"])
```

### Select Menus
```python
@app.event("app_mention")
async def send_task_selector(event, say):
    await say(
        blocks=[
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "What would you like me to help with?"
                },
                "accessory": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Select a task"
                    },
                    "options": [
                        {
                            "text": {"type": "plain_text", "text": "Research"},
                            "value": "research"
                        },
                        {
                            "text": {"type": "plain_text", "text": "Summarize"},
                            "value": "summarize"
                        },
                        {
                            "text": {"type": "plain_text", "text": "Generate"},
                            "value": "generate"
                        }
                    ],
                    "action_id": "task_select"
                }
            }
        ]
    )

@app.action("task_select")
async def handle_task_selection(ack, body, say):
    await ack()
    
    selected_task = body["actions"][0]["selected_option"]["value"]
    user = body["user"]["id"]
    
    if selected_task == "research":
        await say(f"<@{user}> What topic would you like me to research?")
    elif selected_task == "summarize":
        await say(f"<@{user}> Please share the text you'd like summarized.")
    elif selected_task == "generate":
        await say(f"<@{user}> What would you like me to generate?")
```

## Slash Commands

### Complex Command Handling
```python
@app.command("/agent")
async def handle_agent_command(ack, body, say, client):
    await ack()
    
    command_text = body.get("text", "").strip()
    user_id = body["user_id"]
    channel_id = body["channel_id"]
    
    # Parse command
    parts = command_text.split()
    if not parts:
        await show_help(say)
        return
    
    action = parts[0].lower()
    args = parts[1:]
    
    if action == "help":
        await show_help(say)
    
    elif action == "research":
        if not args:
            await say("Usage: `/agent research <topic>`")
            return
        
        topic = " ".join(args)
        await research_topic(topic, say, channel_id)
    
    elif action == "summarize":
        # Get last N messages from channel
        count = int(args[0]) if args and args[0].isdigit() else 10
        await summarize_channel(channel_id, count, say, client)
    
    elif action == "status":
        await show_agent_status(say)
    
    else:
        await say(f"Unknown action: {action}")

async def show_help(say):
    help_text = """
    *Agent Commands:*
    â€¢ `/agent help` - Show this help message
    â€¢ `/agent research <topic>` - Research a topic
    â€¢ `/agent summarize [count]` - Summarize last N messages
    â€¢ `/agent status` - Show agent status
    """
    await say(help_text)
```

## Reaction Events

### Emoji Reactions as Commands
```python
@app.event("reaction_added")
async def handle_reaction(event, say, client):
    reaction = event["reaction"]
    user = event["user"]
    
    # Get the message that was reacted to
    channel = event["item"]["channel"]
    message_ts = event["item"]["ts"]
    
    # Define reaction commands
    reaction_commands = {
        "bookmark": save_message,
        "eyes": analyze_message,
        "memo": summarize_message,
        "robot_face": process_with_ai,
        "x": delete_bot_response
    }
    
    if reaction in reaction_commands:
        # Get original message
        result = await client.conversations_history(
            channel=channel,
            latest=message_ts,
            limit=1,
            inclusive=True
        )
        
        if result["messages"]:
            original_message = result["messages"][0]
            await reaction_commands[reaction](
                original_message, 
                channel, 
                user, 
                say
            )

async def summarize_message(message, channel, user, say):
    thread = Thread()
    msg = Message(
        role="user",
        content=f"Summarize this message: {message['text']}"
    )
    thread.add_message(msg)
    
    processed_thread, new_messages = await agent.go(thread)
    
    await say(
        channel=channel,
        thread_ts=message["ts"],
        text=f"<@{user}> Summary: {new_messages[-1].content}"
    )
```

## Event Combinations

### Context-Aware Responses
```python
class ContextAwareBot:
    def __init__(self):
        self.user_contexts = {}
        self.channel_contexts = {}
    
    async def track_context(self, event):
        user_id = event.get("user")
        channel_id = event.get("channel")
        event_type = event.get("type")
        
        # Update user context
        if user_id:
            if user_id not in self.user_contexts:
                self.user_contexts[user_id] = []
            
            self.user_contexts[user_id].append({
                "type": event_type,
                "time": event.get("ts"),
                "channel": channel_id
            })
        
        # Update channel context
        if channel_id:
            if channel_id not in self.channel_contexts:
                self.channel_contexts[channel_id] = {
                    "active_users": set(),
                    "recent_topics": []
                }
            
            if user_id:
                self.channel_contexts[channel_id]["active_users"].add(user_id)

bot_context = ContextAwareBot()

@app.event("message")
async def handle_with_context(event, say):
    await bot_context.track_context(event)
    
    # Use context for smarter responses
    user_id = event.get("user")
    user_history = bot_context.user_contexts.get(user_id, [])
    
    # Check if user is asking follow-up
    if len(user_history) > 1:
        # Provide contextual response
        pass
```

## Performance Optimization

### Batch Processing
```python
from asyncio import Queue, create_task

class EventBatcher:
    def __init__(self, batch_size=10, timeout=5):
        self.queue = Queue()
        self.batch_size = batch_size
        self.timeout = timeout
        self.processing = False
    
    async def add_event(self, event):
        await self.queue.put(event)
        
        if not self.processing:
            create_task(self.process_batch())
    
    async def process_batch(self):
        self.processing = True
        batch = []
        
        while True:
            try:
                # Collect events
                while len(batch) < self.batch_size:
                    event = await asyncio.wait_for(
                        self.queue.get(), 
                        timeout=self.timeout
                    )
                    batch.append(event)
            except asyncio.TimeoutError:
                pass
            
            if batch:
                # Process batch
                await self.handle_batch(batch)
                batch = []
            
            if self.queue.empty():
                self.processing = False
                break
    
    async def handle_batch(self, events):
        # Group by type
        grouped = {}
        for event in events:
            event_type = event.get("type")
            if event_type not in grouped:
                grouped[event_type] = []
            grouped[event_type].append(event)
        
        # Process each type
        for event_type, type_events in grouped.items():
            if event_type == "message":
                await self.batch_process_messages(type_events)

batcher = EventBatcher()

@app.event("message")
async def handle_message_batched(event):
    await batcher.add_event(event)
```

## Error Handling

### Graceful Event Handling
```python
import logging
from functools import wraps

def safe_event_handler(func):
    @wraps(func)
    async def wrapper(event, *args, **kwargs):
        try:
            return await func(event, *args, **kwargs)
        except Exception as e:
            logging.error(f"Error in {func.__name__}: {str(e)}")
            
            # Notify user if possible
            if "say" in kwargs:
                say = kwargs["say"]
                await say(
                    "I encountered an error processing that request. "
                    "Please try again or contact support."
                )
    
    return wrapper

@app.event("message")
@safe_event_handler
async def handle_message_safely(event, say):
    # Your event handling code
    pass
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Slack Deployment"
    icon="rocket"
    href="/guides/slack-deployment"
  >
    Deploy your bot to production
  </Card>
  <Card
    title="Advanced Patterns"
    icon="diagram-project"
    href="/guides/patterns"
  >
    Complex bot patterns
  </Card>
  <Card
    title="Performance"
    icon="gauge"
    href="/guides/performance"
  >
    Optimize bot performance
  </Card>
  <Card
    title="Monitoring"
    icon="chart-line"
    href="/guides/monitoring"
  >
    Monitor your Slack bot
  </Card>
</CardGroup> 