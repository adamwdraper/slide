---
title: 'AgentResult'
description: 'Result object from non-streaming agent execution'
---

## Overview

The `AgentResult` class encapsulates the complete result of an agent's execution in non-streaming mode. It provides access to the updated thread, new messages, the final output, and detailed execution telemetry.

## Class Definition

```python
@dataclass
class AgentResult:
    thread: Thread                    # Updated thread with new messages
    messages: List[Message]           # New messages added during execution
    output: Optional[str]             # Final assistant response content
    execution: ExecutionDetails       # Full execution telemetry
```

## Properties

<ParamField path="thread" type="Thread">
  The updated thread containing all messages including those added during this execution
</ParamField>

<ParamField path="messages" type="List[Message]">
  List of new messages added during this execution (excludes pre-existing messages)
</ParamField>

<ParamField path="output" type="Optional[str]">
  The final assistant response content. None if no assistant message was generated
</ParamField>

<ParamField path="execution" type="ExecutionDetails">
  Comprehensive execution telemetry including events, timing, and metrics
</ParamField>

<ParamField path="final_output" type="Optional[str]">
  Alias for `output` (provides compatibility with OpenAI SDK style)
</ParamField>

<ParamField path="success" type="bool">
  Whether the execution completed without errors
</ParamField>

## Usage Examples

### Basic Usage

```python
from tyler import Agent, Thread, Message

agent = Agent(name="MyAgent", purpose="To help users")
thread = Thread()
thread.add_message(Message(role="user", content="Hello!"))

# Execute and get result
result = await agent.go(thread)

# Access the response
print(f"Response: {result.output}")
print(f"Success: {result.success}")
```

### Accessing Execution Details

```python
# Get execution metrics
print(f"Duration: {result.execution.duration_ms}ms")
print(f"Tokens used: {result.execution.total_tokens}")
print(f"Iterations: {result.execution.total_iterations}")

# Check tool usage
for tool_call in result.execution.tool_calls:
    print(f"Tool: {tool_call.tool_name}")
    print(f"  Success: {tool_call.success}")
    print(f"  Duration: {tool_call.duration_ms}ms")
```

### Working with Messages

```python
# Access all new messages
for message in result.messages:
    print(f"{message.role}: {message.content}")
    
    # Check for tool calls
    if message.tool_calls:
        print(f"  Tool calls: {len(message.tool_calls)}")
    
    # Check metrics
    if message.metrics:
        tokens = message.metrics.get("usage", {})
        print(f"  Tokens: {tokens.get('total_tokens', 0)}")
```

### Error Handling

```python
result = await agent.go(thread)

if not result.success:
    # Find error events
    for event in result.execution.events:
        if event.type == EventType.EXECUTION_ERROR:
            print(f"Error: {event.data['message']}")
            print(f"Type: {event.data['error_type']}")
    
    # The output may still contain an error message
    if result.output:
        print(f"Error response: {result.output}")
```

### Thread Management

```python
# The thread is updated in-place
original_message_count = len(thread.messages)
result = await agent.go(thread)
new_message_count = len(result.thread.messages)

print(f"Added {new_message_count - original_message_count} messages")

# You can also access the thread directly
assert result.thread is thread  # Same object, modified in-place
```

## Common Patterns

### Conversation Loop

```python
async def chat_loop(agent: Agent, thread: Thread):
    while True:
        user_input = input("You: ")
        if user_input.lower() == 'quit':
            break
            
        thread.add_message(Message(role="user", content=user_input))
        result = await agent.go(thread)
        
        print(f"Assistant: {result.output}")
        print(f"(Took {result.execution.duration_ms:.0f}ms)")
```

### Result Analysis

```python
def analyze_result(result: AgentResult):
    """Analyze agent execution results"""
    stats = {
        "success": result.success,
        "duration_ms": result.execution.duration_ms,
        "tokens": result.execution.total_tokens,
        "tool_calls": len(result.execution.tool_calls),
        "messages_added": len(result.messages),
        "has_output": result.output is not None
    }
    
    # Check for specific events
    event_types = [e.type for e in result.execution.events]
    stats["used_tools"] = EventType.TOOL_SELECTED in event_types
    stats["had_errors"] = EventType.EXECUTION_ERROR in event_types
    
    return stats
```

### Persisting Results

```python
from narrator import ThreadStore

store = ThreadStore()

# Execute agent
result = await agent.go(thread)

# Save the updated thread
await store.save(result.thread)

# Store execution metadata
await store.update_metadata(
    thread_id=result.thread.id,
    metadata={
        "last_execution_ms": result.execution.duration_ms,
        "last_tokens_used": result.execution.total_tokens,
        "last_success": result.success
    }
)
```

## See Also

- [ExecutionDetails](/api-reference/tyler-executiondetails) - Detailed execution telemetry
- [Thread](/api-reference/tyler-thread) - Conversation management
- [Agent](/api-reference/tyler-agent) - The main agent class
- [ExecutionEvent](/api-reference/tyler-executionevent) - Individual execution events
