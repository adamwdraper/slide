---
title: 'ToolCall (Deprecated)'
description: 'This class has been removed - tool information is now available through Thread and Message objects'
---

## Overview

<Note>
**Important**: The `ToolCall` class has been removed from Tyler. Tool execution information is now accessible through Thread utility methods and message content.
</Note>

## Migration Guide

### Accessing Tool Usage Information

**Before:**
```python
result = await agent.go(thread)
for tool_call in result.execution.tool_calls:
    print(f"Tool: {tool_call.tool_name}")
    print(f"Arguments: {tool_call.arguments}")
    print(f"Success: {tool_call.success}")
```

**After:**
```python
result = await agent.go(thread)

# Get tool usage summary
tool_usage = result.thread.get_tool_usage()
print(f"Total tool calls: {tool_usage['total_calls']}")
for tool_name, count in tool_usage['tools'].items():
    print(f"{tool_name}: {count} calls")

# For detailed tool information, examine messages
for msg in result.new_messages:
    if msg.role == "assistant" and msg.tool_calls:
        for tc in msg.tool_calls:
            tool_name = tc.get("function", {}).get("name") if isinstance(tc, dict) else tc.function.name
            print(f"Tool called: {tool_name}")
    elif msg.role == "tool":
        print(f"Tool result: {msg.content}")
```

### Tool Call Details in Messages

Tool calls are stored in assistant messages and their results in tool messages:

```python
# Find all assistant messages with tool calls
for message in thread.messages:
    if message.role == "assistant" and message.tool_calls:
        print(f"\nAssistant called {len(message.tool_calls)} tools:")
        for tool_call in message.tool_calls:
            if isinstance(tool_call, dict):
                tool_name = tool_call.get("function", {}).get("name")
                tool_args = tool_call.get("function", {}).get("arguments")
                tool_id = tool_call.get("id")
            else:
                # Handle OpenAI tool call objects
                tool_name = tool_call.function.name
                tool_args = tool_call.function.arguments
                tool_id = tool_call.id
                
            print(f"  - {tool_name} (ID: {tool_id})")
            print(f"    Args: {tool_args}")

# Find corresponding tool results
for message in thread.messages:
    if message.role == "tool":
        print(f"\nTool result for {message.tool_call_id}:")
        print(f"  {message.content}")
```

### Performance Analysis

To analyze tool performance, you can calculate timing from message timestamps:

```python
def analyze_tool_performance(thread):
    """Analyze tool call performance from thread messages"""
    tool_timings = {}
    
    # Group messages by turn for timing analysis
    turns = thread.get_turns_summary()
    
    # Extract tool usage per turn
    for turn_num, turn_info in turns.items():
        messages = thread.get_messages_by_turn(turn_num)
        
        # Find tool calls and results in this turn
        for msg in messages:
            if msg.role == "assistant" and msg.tool_calls:
                # Record tool call timestamp
                for tc in msg.tool_calls:
                    tool_name = (tc.get("function", {}).get("name") 
                               if isinstance(tc, dict) 
                               else tc.function.name)
                    if tool_name not in tool_timings:
                        tool_timings[tool_name] = []
    
    return tool_timings
```

### Error Handling

Tool errors are now captured in tool messages:

```python
# Find tool errors
for message in thread.messages:
    if message.role == "tool":
        # Check if the tool message indicates an error
        if "error" in message.content.lower() or "failed" in message.content.lower():
            print(f"Tool error for {message.tool_call_id}: {message.content}")
```

## Streaming Mode

In streaming mode, tool events are still emitted as ExecutionEvents:

```python
async for event in agent.go(thread, stream=True):
    if event.type == EventType.TOOL_SELECTED:
        print(f"Tool selected: {event.data['tool_name']}")
        print(f"Arguments: {event.data['arguments']}")
    elif event.type == EventType.TOOL_RESULT:
        print(f"Tool succeeded: {event.data['result']}")
    elif event.type == EventType.TOOL_ERROR:
        print(f"Tool failed: {event.data['error']}")
```

## Why This Change?

The `ToolCall` class was removed because:
1. Tool call information is already stored in assistant messages
2. Tool results are already stored in tool messages
3. Thread utility methods provide aggregated tool usage
4. Less redundancy and simpler data model

## See Also

- [Thread](/api-reference/tyler-thread) - Thread methods for tool usage
- [Message](/api-reference/tyler-message) - Message structure with tool calls
- [EventType](/api-reference/tyler-eventtype) - Tool-related events for streaming
- [Agent](/api-reference/tyler-agent) - Tool configuration