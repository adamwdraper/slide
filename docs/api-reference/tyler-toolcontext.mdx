---
title: 'ToolContext'
description: 'Dataclass for dependency injection and metadata in tools'
---

## Overview

`ToolContext` is a dataclass that represents the runtime context passed to tool functions. It enables dependency injection, allowing tools to access databases, API clients, user information, and other runtime dependencies. It also provides metadata about the current tool execution.

## Class Definition

```python
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, Callable, Awaitable

@dataclass
class ToolContext:
    """Context passed to tools during execution."""
    tool_name: Optional[str] = None      # Name of the tool being executed
    tool_call_id: Optional[str] = None   # Unique ID for this tool call
    deps: Dict[str, Any] = field(default_factory=dict)  # User dependencies
    progress_callback: Optional[Callable[[int, int, str], Awaitable[None]]] = None  # For progress updates
```

## Features

- **Typed metadata fields**: Access `tool_name` and `tool_call_id` directly
- **Dict-style access**: Full backward compatibility with `ctx["key"]` syntax
- **Dependency injection**: Pass databases, API clients, user info to tools

## Using ToolContext

### Accessing Dependencies (Dict-Style)

Tools access user-provided dependencies using dict-style syntax:

```python
from tyler import ToolContext

async def get_user_data(ctx: ToolContext, user_id: str) -> str:
    """Get user data from the database."""
    db = ctx["db"]           # Access deps with []
    user = await db.get_user(user_id)
    return f"User: {user.name}, Email: {user.email}"
```

### Accessing Metadata Fields

Tools can also access typed metadata about the current execution:

```python
async def logged_operation(ctx: ToolContext, action: str) -> str:
    """Perform an action with logging."""
    # Access typed metadata fields directly
    print(f"Tool: {ctx.tool_name}")
    print(f"Call ID: {ctx.tool_call_id}")
    
    # Access user deps with dict-style
    logger = ctx.get("logger")
    if logger:
        logger.info(f"Executing {action} in tool {ctx.tool_name}")
    
    return f"Completed: {action}"
```

### In Tool Definitions

Tools that need runtime dependencies declare a `ctx` or `context` parameter as their first argument:

```python
from tyler import ToolContext

async def get_user_data(ctx: ToolContext, user_id: str) -> str:
    """Get user data from the database."""
    db = ctx["db"]
    user = await db.get_user(user_id)
    return f"User: {user.name}, Email: {user.email}"
```

### Passing Context to Agent

Context can be provided at two levels:

#### Agent-Level Context (Static Dependencies)

Set default context when creating the agent. This is ideal for static dependencies that don't change between requests:

```python
from tyler import Agent, Thread, Message

agent = Agent(
    name="assistant",
    model_name="gpt-4o",
    tools=[user_data_tool],
    tool_context={
        "db": database_connection,
        "config": app_config
    }
)

# All runs automatically get db and config
result = await agent.run(thread)
```

#### Run-Level Context (Request-Scoped Dependencies)

Provide or override context per-run for request-specific data:

```python
# Override db for testing, config still inherited from agent
result = await agent.run(
    thread,
    tool_context={
        "db": test_database,
        "current_user": current_user  # Add request-scoped data
    }
)
```

#### Context Merging

When both agent-level and run-level contexts are provided, they are merged with run-level taking precedence:

```python
agent = Agent(
    tool_context={"db": prod_db, "config": app_config}
)

# Final context: {"db": test_db, "config": app_config, "user": current_user}
await agent.run(thread, tool_context={"db": test_db, "user": current_user})
```

## Parameter Naming Convention

The tool runner looks for specific parameter names to identify context parameters:

<ParamField path="ctx" type="ToolContext">
  Preferred short form. Must be the first parameter.
  
  ```python
  async def my_tool(ctx: ToolContext, param: str) -> str:
      ...
  ```
</ParamField>

<ParamField path="context" type="ToolContext">
  Alternative longer form. Must be the first parameter.
  
  ```python
  async def my_tool(context: ToolContext, param: str) -> str:
      ...
  ```
</ParamField>

<Warning>
The context parameter **must** be the first parameter in your function signature. If it appears elsewhere, it won't receive the injected context.
</Warning>

## Typed Fields

These fields are automatically populated by the agent:

| Field | Type | Description |
|-------|------|-------------|
| `tool_name` | `str \| None` | Name of the tool being executed |
| `tool_call_id` | `str \| None` | Unique identifier for this tool call |
| `deps` | `Dict[str, Any]` | User-provided dependencies |
| `progress_callback` | `Callable \| None` | Async callback for reporting progress (MCP tools) |

```python
async def my_tool(ctx: ToolContext, param: str) -> str:
    # Typed field access
    print(f"Running: {ctx.tool_name}")       # e.g., "my_tool"
    print(f"Call ID: {ctx.tool_call_id}")    # e.g., "call_abc123"
    
    # Dict access to user deps
    db = ctx["db"]  # Accesses ctx.deps["db"]
    return "done"
```

## Dict-Style Access Methods

`ToolContext` supports full dict-style access for backward compatibility:

| Method | Example | Description |
|--------|---------|-------------|
| `[]` | `ctx["key"]` | Get value, raises `KeyError` if missing |
| `[]=` | `ctx["key"] = val` | Set value |
| `get()` | `ctx.get("key", default)` | Get with default |
| `in` | `"key" in ctx` | Check key exists |
| `keys()` | `ctx.keys()` | Iterate over keys |
| `items()` | `ctx.items()` | Iterate over key-value pairs |
| `values()` | `ctx.values()` | Iterate over values |
| `len()` | `len(ctx)` | Count of deps |

## Common Dependency Keys

Here are common keys used in the `deps` dictionary:

| Key | Type | Description |
|-----|------|-------------|
| `db` | Database | Database connection or ORM session |
| `current_user` | User | Currently authenticated user object |
| `user_id` | str | Current user's ID |
| `config` | dict | Application configuration |
| `api_client` | Any | External API client instance |
| `cache` | Cache | Caching layer |
| `logger` | Logger | Logging instance |

## Examples

### Database Access

```python
async def query_orders(ctx: ToolContext, status: str, limit: int = 10) -> str:
    """Query orders from the database."""
    db = ctx["db"]
    user_id = ctx["user_id"]
    
    orders = await db.query(
        "SELECT * FROM orders WHERE user_id = ? AND status = ? LIMIT ?",
        [user_id, status, limit]
    )
    
    return json.dumps([dict(o) for o in orders])
```

### API Client

```python
async def send_notification(ctx: ToolContext, message: str, channel: str) -> str:
    """Send a notification via Slack."""
    slack = ctx["slack_client"]
    
    response = await slack.chat_postMessage(
        channel=channel,
        text=message
    )
    
    return f"Notification sent: {response['ts']}"
```

### User Context

```python
async def get_personalized_recommendations(ctx: ToolContext, category: str) -> str:
    """Get recommendations based on user preferences."""
    user = ctx["current_user"]
    recommender = ctx["recommendation_service"]
    
    recs = await recommender.get_recommendations(
        user_id=user.id,
        preferences=user.preferences,
        category=category
    )
    
    return json.dumps(recs)
```

### Configuration Access

```python
async def fetch_external_data(ctx: ToolContext, query: str) -> str:
    """Fetch data from external API with configured settings."""
    config = ctx["config"]
    http_client = ctx["http_client"]
    
    api_url = config["external_api_url"]
    api_key = config["external_api_key"]
    
    response = await http_client.get(
        f"{api_url}/search",
        params={"q": query},
        headers={"Authorization": f"Bearer {api_key}"}
    )
    
    return response.text
```

## Error Handling

### Missing Context

When a tool expects context but none is provided:

```python
from tyler import ToolContextError

async def requires_db(ctx: ToolContext, query: str) -> str:
    db = ctx["db"]  # KeyError if 'db' not in context
    ...

# This raises ToolContextError
try:
    result = await agent.run(thread)  # No tool_context!
except ToolContextError as e:
    print(f"Missing context: {e}")
```

### Missing Keys

Handle missing keys gracefully:

```python
async def flexible_tool(ctx: ToolContext, action: str) -> str:
    # Check for required keys
    if "db" not in ctx:
        raise ValueError("This tool requires 'db' in context")
    
    # Use optional keys with defaults
    logger = ctx.get("logger", logging.getLogger(__name__))
    cache = ctx.get("cache")
    
    if cache:
        cached = await cache.get(action)
        if cached:
            return cached
    
    # ... rest of implementation
```

## Backward Compatibility

### Tools Without Context

Tools without a context parameter work normally:

```python
# This tool doesn't use context
async def simple_math(a: int, b: int) -> str:
    return str(a + b)

# Context is ignored for this tool
await agent.run(
    thread,
    tool_context={"db": database}  # Passed but not used
)
```

### Existing Code Works Unchanged

The `ToolContext` dataclass is fully backward compatible. Existing tools using dict-style access continue to work:

```python
# This code works the same before and after the update
async def existing_tool(ctx: ToolContext, query: str) -> str:
    db = ctx["db"]                    # Still works
    user_id = ctx.get("user_id")      # Still works
    if "config" in ctx:               # Still works
        config = ctx["config"]
    return "done"
```

## Testing with Context

Mock context for testing:

```python
import pytest
from unittest.mock import AsyncMock, MagicMock

@pytest.mark.asyncio
async def test_query_orders():
    # Create mock context
    mock_db = AsyncMock()
    mock_db.query.return_value = [
        {"id": 1, "status": "pending"},
        {"id": 2, "status": "pending"}
    ]
    
    ctx = {
        "db": mock_db,
        "user_id": "user_123"
    }
    
    # Call tool directly
    result = await query_orders(ctx, status="pending", limit=10)
    
    # Verify
    assert "pending" in result
    mock_db.query.assert_called_once()
```

## Best Practices

### Type Documentation

Document expected context keys in your tool's docstring:

```python
async def complex_tool(ctx: ToolContext, param: str) -> str:
    """
    Perform a complex operation.
    
    Args:
        ctx: Runtime context containing:
            - db (Database): Required. Database connection.
            - cache (Cache): Optional. Caching layer.
            - config (dict): Required. Application config with 'api_url' key.
        param: The operation parameter.
    
    Returns:
        Operation result as JSON string.
    """
```

### Validation Helper

Create a validation helper for complex context requirements:

```python
def validate_context(ctx: ToolContext, required: list[str]) -> None:
    """Validate that context contains required keys."""
    missing = [key for key in required if key not in ctx]
    if missing:
        raise ValueError(f"Context missing required keys: {missing}")

async def my_tool(ctx: ToolContext, param: str) -> str:
    validate_context(ctx, ["db", "user_id", "config"])
    ...
```

### Context Factory

Create context consistently across your application using agent-level context for static dependencies and run-level for request-scoped data:

```python
# Static dependencies at agent level
agent = Agent(
    model_name="gpt-4o",
    tool_context={
        "db": database,
        "config": app_config
    }
)

# Request-scoped factory for user context
class UserContextFactory:
    def create(self, user: User) -> dict:
        return {
            "current_user": user,
            "user_id": user.id,
            "logger": logging.getLogger(f"tools.{user.id}")
        }

# Usage - user context merged with agent's db/config
factory = UserContextFactory()
result = await agent.run(thread, tool_context=factory.create(current_user))
# Tool receives: db, config, current_user, user_id, logger
```

## See Also

- [Agent](/api-reference/tyler-agent) - Agent.run() with tool_context
- [Adding Tools](/guides/adding-tools) - Creating custom tools
- [Structured Output Guide](/guides/structured-output) - Complete guide including tool context

